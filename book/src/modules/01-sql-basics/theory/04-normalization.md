# 9.4. Нормализация баз данных

Проектирование структуры базы данных — один из важнейших этапов разработки. **Нормализация** — это формальный процесс организации данных в базе, главная цель которого — устранить избыточность (дублирование) данных и аномалии их изменения.

**Аномалии** — это проблемы, которые возникают в плохо спроектированных базах данных:
*   **Аномалия вставки**: Невозможность вставить информацию об одном объекте без информации о другом. (Например, нельзя добавить новый курс, пока на него не запишется хотя бы один студент).
*   **Аномалия обновления**: При изменении повторяющихся данных приходится обновлять их во всех местах, где они встречаются, что чревато ошибками. (Например, при смене названия курса его придется менять в записи у каждого студента).
*   **Аномалия удаления**: Удаление одной части информации приводит к случайной потере другой. (Например, если последний студент отписался от курса, мы теряем всю информацию о существовании этого курса).

Нормализация помогает спроектировать таблицы так, чтобы избежать этих проблем. Процесс состоит из последовательного приведения таблиц к **нормальным формам**.

## Первая нормальная форма (1NF)

**Правило:** Таблица находится в 1NF, если все её атрибуты (значения в ячейках) являются **атомарными** (неделимыми). Проще говоря, в одной ячейке не может быть списка значений.

**Плохой пример (не в 1NF):**
| student_id | student_name | courses                                |
|------------|--------------|----------------------------------------|
| 1          | Иван Петров  | 'Математика, Физика'                   |
| 2          | Мария Козлова| 'История'                              |

Здесь поле `courses` неатомарно. Это затрудняет поиск всех студентов курса "Физика" и требует парсинга строки.

**Хороший пример (в 1NF):**
Для решения проблемы создают отдельную таблицу для связи студентов и курсов.

**Таблица `students`:**
| student_id | student_name |
|------------|--------------|
| 1          | Иван Петров  |
| 2          | Мария Козлова|

**Таблица `courses`:**
| course_id  | course_name |
|------------|-------------|
| 101        | Математика  |
| 102        | Физика      |
| 103        | История     |

**Таблица `student_courses` (связующая):**
| student_id | course_id |
|------------|-----------|
| 1          | 101       |
| 1          | 102       |
| 2          | 103       |

Теперь все данные атомарны, и мы решили проблему 1NF.

## Вторая нормальная форма (2NF)

**Правило:** Таблица находится в 2NF, если она:
1.  Находится в 1NF.
2.  Все её неключевые атрибуты **полностью зависимы** от составного первичного ключа.

Это правило актуально только для таблиц, у которых первичный ключ состоит из нескольких колонок (составной ключ). Оно означает, что ни один из неключевых столбцов не должен зависеть только от *части* составного ключа.

**Плохой пример (не в 2NF):**
Предположим, у нас есть таблица оценок, где первичный ключ — (`student_id`, `course_id`).
| student_id | course_id | **course_name** | grade |
|------------|-----------|-----------------|-------|
| 1          | 101       | Математика      | 5     |
| 1          | 102       | Физика          | 4     |
| 2          | 101       | Математика      | 5     |

Здесь `course_name` зависит только от `course_id`, то есть от *части* составного ключа. Это приводит к дублированию названия курса и аномалии обновления (если мы захотим переименовать "Математику" в "Высшую математику").

**Хороший пример (в 2NF):**
Информация о курсах выносится в отдельную таблицу, как мы уже сделали в примере для 1NF. Таблица `student_courses` будет содержать только `student_id`, `course_id` и `grade`.

## Третья нормальная форма (3NF)

**Правило:** Таблица находится в 3NF, если она:
1.  Находится в 2NF.
2.  Отсутствуют **транзитивные зависимости**.

Транзитивная зависимость — это когда неключевой атрибут зависит от другого неключевого атрибута.

**Плохой пример (не в 3NF):**
Допустим, в таблице сотрудников есть данные о руководителе отдела.
| employee_id | employee_name | department_name | **department_head** |
|-------------|---------------|-----------------|---------------------|
| 1           | Иван Петров   | IT              | Сидоров А.В.        |
| 2           | Мария Козлова | IT              | Сидоров А.В.        |
| 3           | Ольга Морозова| HR              | Иванова А.А.        |

Здесь `department_head` зависит от `department_name`, который сам не является ключом. Если сменится глава IT-отдела, нам придется обновить это значение во всех строках для сотрудников IT. Это транзитивная зависимость (`employee_id` -> `department_name` -> `department_head`).

**Хороший пример (в 3NF):**
Создаем отдельную таблицу `departments`.

**Таблица `employees`:**
| employee_id | employee_name | department_id |
|-------------|---------------|---------------|
| 1           | Иван Петров   | 1             |
| 2           | Мария Козлова | 1             |
| 3           | Ольга Морозова| 2             |

**Таблица `departments`:**
| department_id | department_name | department_head |
|---------------|-----------------|-----------------|
| 1             | IT              | Сидоров А.В.    |
| 2             | HR              | Иванова А.А.    |

Теперь данные о руководителе хранятся в одном месте, и аномалии устранены.

### Итог

Чаще всего на практике достаточно приведения базы данных к 3NF. Это обеспечивает хороший баланс между устранением избыточности и сложностью схемы данных. Существуют и другие нормальные формы (BCNF, 4NF, 5NF), но они применяются для решения более специфических и редких проблем. 